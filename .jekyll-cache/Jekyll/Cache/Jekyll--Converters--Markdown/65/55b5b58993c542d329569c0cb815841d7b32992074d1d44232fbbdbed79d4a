I"<p>Bir yazÄ±lÄ±m projesinde tasarlanan sÄ±nÄ±flar (class) ve yapÄ±lar (struct), bazen benzer gÃ¶revleri yerine getirebilmektedir. BÃ¶yle durumlarda sÄ±nÄ±flarÄ±n hangi gÃ¶revleri yerine getireceÄŸi konusunda karÄ±ÅŸÄ±klÄ±klar ortaya Ã§Ä±kabilmektedir. Single Responsibility Prensibine gÃ¶re bu tarz karmaÅŸanÄ±n Ã¶nÃ¼ne geÃ§mek iÃ§in sÄ±nÄ±flarÄ±n ve yapÄ±larÄ±n iyi tanÄ±mlanmÄ±ÅŸ tek sorumluluÄŸu olmasÄ± gerekmektedir. EÄŸer bir sÄ±nÄ±f birden fazla gÃ¶revin yerine getirilmesinden sorumlu olursa, gelecekte bu sÄ±nÄ±fÄ±n deÄŸiÅŸme ihtimalini de arttÄ±rmaktadÄ±r. Bu da yazÄ±lÄ±m tasarÄ±mÄ±nÄ±n bozulacaÄŸÄ± anlamÄ±na gelmektedir.</p>

<p>Bu Ã§alÄ±ÅŸmada Ã¶ncelikle SRPâ€™ye uygun olmayan basit bir tasarÄ±mla baÅŸlanarak, onu SRPâ€™ye uygun hale getirilmeye Ã§alÄ±ÅŸÄ±lacaktÄ±r. Ã–rnek olarak geometrik ÅŸekillerin Ã§evresini hesaplayan ve bu ÅŸekillerin Ã§evrelerinin toplamÄ±nÄ± ekrana yazdÄ±ran basit bir console uygulamasÄ± yapÄ±lacaktÄ±r. BaÅŸlangÄ±Ã§ olarak Ã¶rneÄŸin UML diyagramÄ± aÅŸaÄŸÄ±daki gibidir;</p>

<p><img src="/images/solid/srp/srp-uml-1.png" alt="Single Responsibility Principle Example UML - 1" /></p>

<p>Åekil 1. Console uygulamasÄ±nÄ±n SRPâ€™den Ã¶nceki halinin UML diyagramÄ±</p>

<p>Â </p>

<p><code class="language-plaintext highlighter-rouge">IShape</code> interfaceâ€™i ve bunu implement eden <code class="language-plaintext highlighter-rouge">Square</code> ve <code class="language-plaintext highlighter-rouge">Rectangle</code> classâ€™larÄ±nÄ±n C# kodlarÄ± aÅŸaÄŸÄ±daki gibidir;</p>

<script src="https://gist.github.com/omereryilmaz/1730cbede312f88791c7f35187d687ed.js"></script>

<script src="https://gist.github.com/omereryilmaz/63007ffdd3af638bf22714758dd465e3.js"></script>

<script src="https://gist.github.com/omereryilmaz/0a166eb3f01c59fdc6cc65fdf6f08e3a.js"></script>

<p>Â </p>

<p>Bu sÄ±nÄ±flarÄ± kullanarak iÅŸlem yapan <code class="language-plaintext highlighter-rouge">CalcTotalPerimeter</code> classâ€™Ä±nÄ±n da kodlarÄ± aÅŸaÄŸÄ±daki gibidir;</p>

<script src="https://gist.github.com/omereryilmaz/623e101613a3ee84a63f75d016e635f3.js"></script>

<p>YukarÄ±daki kod incelendiÄŸinde ÅŸekillere ait Ã§evreyi hesaplama metodu olan <code class="language-plaintext highlighter-rouge">CalcPerimeter</code>â€™Ä±n Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± ve bu hesaplamalardan dÃ¶nen deÄŸerleri de totalPerimeter deÄŸiÅŸkeninde toplandÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼lmektedir. Son olarak da hesaplanan toplam Ã§evre deÄŸeri <code class="language-plaintext highlighter-rouge">PrintToConsole</code> metodu ile consoleâ€™a yazdÄ±rÄ±lmaktadÄ±r. Ä°lgili kodu test etmek iÃ§in <code class="language-plaintext highlighter-rouge">Program</code> classâ€™Ä±ndaki Main metoduna aÅŸaÄŸÄ±daki kodlar eklenir;</p>

<script src="https://gist.github.com/omereryilmaz/93c33c404467d941df3bf265b7028373.js"></script>

<p>Ekran Ã‡Ä±ktÄ±sÄ±:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Total Perimeter: 30
</code></pre></div></div>

<p>Ã‡Ä±ktÄ± deÄŸerleri kontrol edildiÄŸinde uygulamanÄ±n doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ± gÃ¶rÃ¼nmektedir. Ancak tasarÄ±msal olarak sorunlar barÄ±ndÄ±rmaktadÄ±r. <code class="language-plaintext highlighter-rouge">CalcTotalPerimeter</code> classâ€™Ä± incelendiÄŸinde hem toplam Ã§evreyi hesaplamakla hem de sonuÃ§larÄ± ekrana yazdÄ±rmakla gÃ¶revlidir. Yani birden fazla sorumluluÄŸa sahiptir. Bu durum sonuÃ§larÄ± yazdÄ±rma gereksinimleri geniÅŸletilmek istenildiÄŸinde veya aynÄ± metodlar baÅŸka sÄ±nÄ±flar iÃ§inde gerekli olduÄŸu durumlarda karmaÅŸaya yola aÃ§abilir. Sonucunda da tasarÄ±mda deÄŸiÅŸikliÄŸe gidilmesi gerekebilir.</p>

<p>Â </p>

<p>Bu tasarÄ±m sorununu gidermek iÃ§in yazdÄ±rma sorumluluÄŸu baÅŸka bir sÄ±nÄ±fa verilmesi gerekmektedir. Bunun iÃ§in <code class="language-plaintext highlighter-rouge">PrintResult</code> isminde bir class oluÅŸturularak, <code class="language-plaintext highlighter-rouge">CalcTotalPerimeter</code> iÃ§erisindeki yazdÄ±rma metodu bu classâ€™a eklenir.</p>

<p><img src="/images/solid/srp/srp-uml-2.png" alt="Single Responsibility Principle Example UML - 2" /></p>

<p>Åekil 2. Console uygulamasÄ±nÄ±n SRPâ€™ye gÃ¶re dÃ¼zenlenmiÅŸ halinin UML diyagramÄ±</p>

<p>Â </p>

<p><code class="language-plaintext highlighter-rouge">PrintResult</code> classâ€™Ä±nÄ±n C# kodu aÅŸaÄŸÄ±daki gibidir;</p>

<script src="https://gist.github.com/omereryilmaz/2cedfcf748bd8670a48e8815546149aa.js"></script>

<p>Â </p>

<p>Bu ÅŸekilde classâ€™larÄ±n sorumluluklarÄ± bire indirgenmiÅŸ oldu. <code class="language-plaintext highlighter-rouge">CalcTotalPerimeter</code> classâ€™Ä± sadece ÅŸekillerin Ã§evrelerinin toplanmasÄ±ndan sorumluyken; <code class="language-plaintext highlighter-rouge">PrintResult</code> classâ€™Ä± da ilgili sonuÃ§larÄ±n yazdÄ±rÄ±lma iÅŸlerinden sorumlu olmuÅŸtur. ArtÄ±k consoleâ€™a ya da bir dosyaya yazdÄ±rma iÅŸlemi yaptÄ±rmak istediÄŸimizde deÄŸiÅŸiklik yapacaÄŸÄ±mÄ±z sadece bir sorumlu classâ€™Ä±mÄ±z olmuÅŸ oldu.</p>

<p>Ä°lgili kodu test etmek iÃ§in <code class="language-plaintext highlighter-rouge">Program</code> classâ€™Ä±ndaki <code class="language-plaintext highlighter-rouge">Main</code> metoduna aÅŸaÄŸÄ±daki kodlar eklenir;</p>

<script src="https://gist.github.com/omereryilmaz/98803e2f09175e2f82ce73eef7557789.js"></script>

<p>Â </p>

<p>SonuÃ§ olarak classâ€™lar sadece bir gÃ¶revi yerine getirmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in daÄŸÄ±nÄ±k olmayan ve okunmasÄ± kolay kod yapÄ±sÄ± elde edildi. Bu sayede tasarÄ±ma, ilgili classâ€™larÄ±n yeniden dÃ¼zenlenebilme, yeni Ã¶zellikler ilave edebilme gibi yetenekler kazandÄ±rÄ±lmÄ±ÅŸ oldu. YukarÄ±daki Ã¶rnekte gÃ¶rÃ¼leceÄŸi Ã¼zere classâ€™lardaki Ã¶zellikler kolaylÄ±kla deÄŸiÅŸtirilip, yeni bir Ã¶zellikler (dosyaya yazdÄ±rma) eklenebildi. AyrÄ±ca classâ€™lar daha baÄŸÄ±msÄ±z bir hale geldi. Bu ÅŸekilde ileride olabilecek gereksinimler doÄŸrultusunda eklenecek olan classâ€™larÄ±n (Ã¶rneÄŸin ÅŸekillerin alanlarÄ±nÄ±n toplamÄ±nÄ± hesaplama) sonuÃ§ Ã§Ä±ktÄ±larÄ± da aynÄ± yazdÄ±rma metodlarÄ±nÄ± kullanarak yazdÄ±rÄ±labilir.</p>

<p>GÃ¼zel tasarlanmÄ±ÅŸ yazÄ±lÄ±m sistemleri meydana getirebilmek iÃ§in okunabilir ve sÃ¼rdÃ¼rÃ¼lebilir kod yazÄ±lmasÄ± temel amaÃ§ edinilmelidir. Bu yÃ¼zden SRPâ€™yi doÄŸru bir ÅŸekilde ve yerinde uygulamak Ã¶nem arz etmektedir. YanlÄ±ÅŸ kullanÄ±mlarda organizasyonu iyi yapÄ±lmamÄ±ÅŸ kÃ¼Ã§Ã¼k parÃ§alardaki classâ€™larÄ±n elde edilmesine neden olabilmektedir. BÃ¶yle sistemlerde ise kod bakÄ±mÄ± ve deÄŸiÅŸiklikler masraflÄ± hale gelmiÅŸ olur.</p>

<p>Â </p>

<p>Ä°lgili Ã–rneÄŸin Kaynak KodlarÄ±: <a href="https://github.com/omereryilmaz/SolidPrinciples">Github - Solid Principles</a></p>

<p>Â 
Â </p>

<h5 id="kaynaklar">Kaynaklar</h5>
<ul>
  <li>[1] The Principles of OOD, http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</li>
  <li>[2] Robert C. Martin and Micah Martin, â€œAgile Principles, Patterns, and Practices in C#â€, 2006.</li>
  <li>[3] Code Maze, https://code-maze.com/solid-principles/</li>
</ul>
:ET